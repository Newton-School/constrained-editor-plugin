{"version":3,"file":"constrainedEditorPlugin.min.js","mappings":"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","sources":["webpack://constrainedEditor/webpack/bootstrap","webpack://constrainedEditor/webpack/runtime/define property getters","webpack://constrainedEditor/webpack/runtime/hasOwnProperty shorthand","webpack://constrainedEditor/./src/utils/validators.js","webpack://constrainedEditor/./src/utils/definedErrors.js","webpack://constrainedEditor/./src/utils/deepClone.js","webpack://constrainedEditor/./src/utils/enums.js","webpack://constrainedEditor/./src/constrainedEditor.js","webpack://constrainedEditor/./src/constrainedModel.js","webpack://constrainedEditor/./src/utils/boundaryUtils.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const validators = {\n  initWith: function (monaco) {\n    const dummyDiv = document.createElement('div');\n    const dummyEditorInstance = monaco.editor.create(dummyDiv);\n    const editorInstanceConstructorName = dummyEditorInstance.constructor.name;\n    const editorModelConstructorName = dummyEditorInstance.getModel().constructor.name;\n    const instanceCheck = function (valueToValidate) {\n      return valueToValidate.constructor.name === editorInstanceConstructorName;\n    }\n    const modelCheck = function (valueToValidate) {\n      return valueToValidate.constructor.name === editorModelConstructorName;\n    }\n    const rangesCheck = function (ranges) {\n      if (Array.isArray(ranges)) {\n        return ranges.every(function (rangeObj) {\n          if (typeof rangeObj === 'object' && rangeObj.constructor.name === 'Object') {\n            if (!rangeObj.hasOwnProperty('range')) return false;\n            if (!Array.isArray(rangeObj.range)) return false;\n            if (rangeObj.range.length !== 4) return false;\n            if (!(rangeObj.range.every(num => num > 0 && parseInt(num) === num))) return false;\n            if (rangeObj.hasOwnProperty('allowMultiline')) {\n              if (typeof rangeObj.allowMultiline !== 'boolean') return false;\n            }\n            if (rangeObj.hasOwnProperty('label')) {\n              if (typeof rangeObj.label !== 'string') return false;\n            }\n            if (rangeObj.hasOwnProperty('validate')) {\n              if (typeof rangeObj.validate !== 'function') return false;\n            }\n            return true;\n          }\n          return false;\n        });\n      }\n      return false;\n    }\n    return {\n      isInstanceValid: instanceCheck,\n      isModelValid: modelCheck,\n      isRangesValid: rangesCheck\n    }\n  }\n}\nexport default validators;","export const TypeMustBe = function (type, key, additional) {\n  return 'The value for the ' + key + ' should be of type ' + (Array.isArray(type) ? type.join(' | ') : type) + '. ' + (additional || '')\n}\nconst definedErrors = {\n  TypeMustBe : TypeMustBe\n};\nexport default definedErrors;","export const deepClone = (function () {\n  const byPassPrimitives = function (value, callback) {\n    if (typeof value !== 'object' || value === null) {\n      return this.freeze ? Object.freeze(value) : value;\n    }\n    if (value instanceof Date) {\n      return this.freeze ? Object.freeze(new Date(value)) : new Date(value);\n    }\n    return callback.call(this, value);\n  }\n  const cloneArray = function (array, callback) {\n    const keys = Object.keys(array);\n    const arrayClone = new Array(keys.length)\n    for (let i = 0; i < keys.length; i++) {\n      arrayClone[keys[i]] = byPassPrimitives.call(this, array[keys[i]], callback);\n    }\n    return arrayClone;\n  }\n  const cloner = function (object) {\n    return byPassPrimitives.call(this, object, function (object) {\n      if (Array.isArray(object)) {\n        return cloneArray.call(this, object, cloner)\n      }\n      const clone = {};\n      for (let key in object) {\n        if (!this.withProto && Object.hasOwnProperty.call(object, key) === false) {\n          continue;\n        }\n        clone[key] = byPassPrimitives.call(this, object[key], cloner);\n      }\n      return clone;\n    })\n  }\n  const config = (function () {\n    const constructOptionForCode = function (value) {\n      const options = [\n        'withProto',\n        'freeze'\n      ]\n      this[value] = options.reduce(function (acc, option) {\n        if (acc[option] = (value >= this[option])) {\n          value -= this[option]\n        }\n        return acc;\n      }.bind(this), {})\n    }\n    const codes = Object.create(Object.defineProperties({}, {\n      withProto: { value: 1 },\n      freeze: { value: 2 }\n    }));\n    for (let i = 0; i <= 3; i++) {\n      constructOptionForCode.call(codes, i);\n    }\n    return codes;\n  }());\n  const methods = {\n    withProto: cloner.bind(config[1]),\n    andFreeze: cloner.bind(config[2]),\n    withProtoAndFreeze: cloner.bind(config[3])\n  }\n  const API = cloner.bind(config[0]);\n  for (let methodName in methods) {\n    Object.defineProperty(API, methodName, {\n      enumerable: false,\n      writable: false,\n      configurable: false,\n      value: methods[methodName]\n    })\n  }\n  return API;\n}());\n\nexport default deepClone;","export const enums = {\n  SINGLE_LINE_HIGHLIGHT_CLASS: 'editableArea--single-line',\n  MULTI_LINE_HIGHLIGHT_CLASS: 'editableArea--multi-line',\n  RESTRICTED_AREA_HIGHLIGHT_CLASS: 'editableArea--restricted',\n  \n}\nexport default enums;","import validators from './utils/validators.js';\nimport { TypeMustBe } from './utils/definedErrors.js';\nimport constrainedModel from './constrainedModel.js';\n\nexport function constrainedEditor(monaco) {\n  /**\n   * Injected Dependencies\n   */\n  if (monaco === undefined) {\n    throw new Error([\n      \"Please pass the monaco global variable into function as\",\n      \"(eg:)constrainedEditor({ range : monaco.range });\",\n    ].join('\\n'));\n  }\n  /**\n   *\n   * @param {Object} editorInstance This should be the monaco editor instance.\n   * @description This is the listener function to check whether the cursor is at checkpoints\n   * (i.e) the point where editable and non editable portions meet\n   */\n  const listenerFn = function (editorInstance) {\n    const model = editorInstance.getModel();\n    if (model._isCursorAtCheckPoint) {\n      const selections = editorInstance.getSelections();\n      const positions = selections.map(function (selection) {\n        return {\n          lineNumber: selection.positionLineNumber,\n          column: selection.positionColumn\n        }\n      });\n      model._isCursorAtCheckPoint(positions);\n      model._currentCursorPositions = selections;\n    }\n  }\n  const _uriRestrictionMap = {};\n  const { isInstanceValid, isModelValid, isRangesValid } = validators.initWith(monaco);\n  /**\n   *\n   * @param {Object} editorInstance This should be the monaco editor instance\n   * @returns {Boolean}\n   */\n  const initInEditorInstance = function (editorInstance) {\n    if (isInstanceValid(editorInstance)) {\n      let domNode = editorInstance.getDomNode();\n      manipulator._listener = listenerFn.bind(API, editorInstance);\n      manipulator._editorInstance = editorInstance;\n      manipulator._editorInstance._isInDevMode = false;\n      domNode.addEventListener('keydown', manipulator._listener, true);\n      manipulator._onChangeModelDisposable = editorInstance.onDidChangeModel(function () {\n        // domNode - refers old dom node\n        domNode && domNode.removeEventListener('keydown', manipulator._listener, true)\n        const newDomNode = editorInstance.getDomNode(); // Gets Current dom node\n        newDomNode && newDomNode.addEventListener('keydown', manipulator._listener, true);\n        domNode = newDomNode;\n      })\n      return true;\n    } else {\n      throw new Error(\n        TypeMustBe(\n          'ICodeEditor',\n          'editorInstance',\n          'This type interface can be found in monaco editor documentation'\n        )\n      )\n    }\n  }\n  /**\n   *\n   * @param {Object} model This should be the monaco editor model instance. Refer https://microsoft.github.io/monaco-editor/api/interfaces/monaco.editor.itextmodel.html\n   * @param {*} ranges This should be the array of range objects. Refer constrained editor plugin documentation\n   * @returns model\n   */\n  const addRestrictionsTo = function (model, ranges) {\n    if (isModelValid(model)) {\n      if (isRangesValid(ranges)) {\n        const modelToConstrain = constrainedModel(model, ranges, monaco, manipulator._editorInstance);\n        _uriRestrictionMap[modelToConstrain.uri.toString()] = modelToConstrain;\n        return modelToConstrain;\n      } else {\n        throw new Error(\n          TypeMustBe(\n            'Array<RangeRestrictionObject>',\n            'ranges',\n            'Please refer constrained editor documentation for proper structure'\n          )\n        )\n      }\n    } else {\n      throw new Error(\n        TypeMustBe(\n          'ICodeEditor',\n          'editorInstance',\n          'This type interface can be found in monaco editor documentation'\n        )\n      )\n    }\n  }\n  /**\n   *\n   * @param {Object} model This should be the monaco editor model instance. Refer https://microsoft.github.io/monaco-editor/api/interfaces/monaco.editor.itextmodel.html\n   * @returns {Boolean} True if the restrictions are removed\n   */\n  const removeRestrictionsIn = function (model) {\n    if (isModelValid(model)) {\n      const uri = model.uri.toString();\n      const restrictedModel = _uriRestrictionMap[uri];\n      if (restrictedModel) {\n        return restrictedModel.disposeRestrictions();\n      } else {\n        console.warn('Current Model is not a restricted Model');\n        return false;\n      }\n    } else {\n      throw new Error(\n        TypeMustBe(\n          'ICodeEditor',\n          'editorInstance',\n          'This type interface can be found in monaco editor documentation'\n        )\n      )\n    }\n  }\n  /**\n   *\n   * @returns {Boolean} True if the constrainer is disposed\n   */\n  const disposeConstrainer = function () {\n    if (manipulator._editorInstance) {\n      const instance = manipulator._editorInstance;\n      const domNode = instance.getDomNode();\n      domNode && domNode.removeEventListener('keydown', manipulator._listener);\n      manipulator._onChangeModelDisposable && manipulator._onChangeModelDisposable.dispose();\n      delete manipulator._listener;\n      delete manipulator._editorInstance._isInDevMode;\n      delete manipulator._editorInstance._devModeAction;\n      delete manipulator._editorInstance;\n      delete manipulator._onChangeModelDisposable;\n      for (let key in _uriRestrictionMap) {\n        delete _uriRestrictionMap[key];\n      }\n      return true;\n    }\n    return false;\n  }\n  /**\n   * @description This function used to make the developer to find the ranges of selected portions\n   */\n  const toggleDevMode = function () {\n    if (manipulator._editorInstance._isInDevMode) {\n      manipulator._editorInstance._isInDevMode = false;\n      manipulator._editorInstance._devModeAction.dispose();\n      delete manipulator._editorInstance._devModeAction;\n    } else {\n      manipulator._editorInstance._isInDevMode = true;\n      manipulator._editorInstance._devModeAction = manipulator._editorInstance.addAction({\n        id: 'showRange',\n        label: 'Show Range in console',\n        contextMenuGroupId: 'navigation',\n        contextMenuOrder: 1.5,\n        run: function (editor) {\n          const selections = editor.getSelections();\n          const ranges = selections.reduce(function (acc, { startLineNumber, endLineNumber, startColumn, endColumn }) {\n            acc.push('range : ' + JSON.stringify([\n              startLineNumber,\n              startColumn,\n              endLineNumber,\n              endColumn\n            ]));\n            return acc;\n          }, []).join('\\n');\n          console.log(`Selected Ranges : \\n` + JSON.stringify(ranges, null, 2));\n        }\n      });\n    }\n  }\n\n  /**\n   * Main Function starts here\n   */\n  // @internal\n  const manipulator = {\n    /**\n     * These variables should not be modified by external code\n     * This has to be used for debugging and testing\n     */\n    _listener: null,\n    _editorInstance: null,\n    _uriRestrictionMap: _uriRestrictionMap,\n    _injectedResources: monaco\n  }\n  const API = Object.create(manipulator);\n  const exposedMethods = {\n    /**\n     * These functions are exposed to the user\n     * These functions should be protected from editing\n     */\n    initializeIn: initInEditorInstance,\n    addRestrictionsTo: addRestrictionsTo,\n    removeRestrictionsIn: removeRestrictionsIn,\n    disposeConstrainer: disposeConstrainer,\n    toggleDevMode: toggleDevMode\n  }\n  for (let methodName in exposedMethods) {\n    Object.defineProperty(API, methodName, {\n      enumerable: false,\n      writable: false,\n      configurable: false,\n      value: exposedMethods[methodName]\n    })\n  }\n  return Object.freeze(API);\n}\n\nexport default constrainedEditor;\n","import { getEditorBoundaryExcludingBoundaryList } from './utils/boundaryUtils.js';\nimport deepClone from './utils/deepClone.js';\nimport enums from './utils/enums.js';\nexport const constrainedModel = function(model, ranges, monaco) {\n  const rangeConstructor = monaco.Range;\n  const sortRangesInAscendingOrder = function(rangeObject1, rangeObject2) {\n    const rangeA = rangeObject1.range;\n    const rangeB = rangeObject2.range;\n    if (\n      rangeA[0] < rangeB[0] ||\n      (rangeA[0] === rangeB[0] && rangeA[3] < rangeB[1])\n    ) {\n      return -1;\n    }\n  };\n  const normalizeRange = function(range, content) {\n    const lines = content.split('\\n');\n    const noOfLines = lines.length;\n    const normalizedRange = [];\n    range.forEach(function(value, index) {\n      if (value === 0) {\n        throw new Error('Range values cannot be zero'); //No I18n\n      }\n      switch (index) {\n        case 0:\n          {\n            if (value < 0) {\n              throw new Error('Start Line of Range cannot be negative'); //No I18n\n            } else if (value > noOfLines) {\n              throw new Error(\n                'Provided Start Line(' +\n                  value +\n                  ') is out of bounds. Max Lines in content is ' +\n                  noOfLines,\n              ); //No I18n\n            }\n            normalizedRange[index] = value;\n          }\n          break;\n        case 1:\n          {\n            let actualStartCol = value;\n            const startLineNo = normalizedRange[0];\n            const maxCols = lines[startLineNo - 1].length;\n            if (actualStartCol < 0) {\n              actualStartCol = maxCols - Math.abs(actualStartCol);\n              if (actualStartCol < 0) {\n                throw new Error(\n                  'Provided Start Column(' +\n                    value +\n                    ') is out of bounds. Max Column in line ' +\n                    startLineNo +\n                    ' is ' +\n                    maxCols,\n                ); //No I18n\n              }\n            } else if (actualStartCol > maxCols + 1) {\n              throw new Error(\n                'Provided Start Column(' +\n                  value +\n                  ') is out of bounds. Max Column in line ' +\n                  startLineNo +\n                  ' is ' +\n                  maxCols,\n              ); //No I18n\n            }\n            normalizedRange[index] = actualStartCol;\n          }\n          break;\n        case 2:\n          {\n            let actualEndLine = value;\n            if (actualEndLine < 0) {\n              actualEndLine = noOfLines - Math.abs(value);\n              if (actualEndLine < 0) {\n                throw new Error(\n                  'Provided End Line(' +\n                    value +\n                    ') is out of bounds. Max Lines in content is ' +\n                    noOfLines,\n                ); //No I18n\n              }\n              if (actualEndLine < normalizedRange[0]) {\n                console.warn(\n                  'Provided End Line(' +\n                    value +\n                    ') is less than the start Line, the Restriction may not behave as expected',\n                ); //No I18n\n              }\n            } else if (value > noOfLines) {\n              throw new Error(\n                'Provided End Line(' +\n                  value +\n                  ') is out of bounds. Max Lines in content is ' +\n                  noOfLines,\n              ); //No I18n\n            }\n            normalizedRange[index] = actualEndLine;\n          }\n          break;\n        case 3:\n          {\n            let actualEndCol = value;\n            const endLineNo = normalizedRange[2];\n            const maxCols = lines[endLineNo - 1].length;\n            if (actualEndCol < 0) {\n              actualEndCol = maxCols - Math.abs(actualEndCol);\n              if (actualEndCol < 0) {\n                throw new Error(\n                  'Provided End Column(' +\n                    value +\n                    ') is out of bounds. Max Column in line ' +\n                    endLineNo +\n                    ' is ' +\n                    maxCols,\n                ); //No I18n\n              }\n            } else if (actualEndCol > maxCols + 1) {\n              throw new Error(\n                'Provided Start Column(' +\n                  value +\n                  ') is out of bounds. Max Column in line ' +\n                  endLineNo +\n                  ' is ' +\n                  maxCols,\n              ); //No I18n\n            }\n            normalizedRange[index] = actualEndCol;\n          }\n          break;\n      }\n    });\n    return normalizedRange;\n  };\n  let restrictions = deepClone(ranges).sort(sortRangesInAscendingOrder);\n  const prepareRestrictions = function(restrictions) {\n    const content = model.getValue();\n    restrictions.forEach(function(restriction, index) {\n      const range = normalizeRange(restriction.range, content);\n      const startLine = range[0];\n      const startCol = range[1];\n      const endLine = range[2];\n      const endCol = range[3];\n      restriction._originalRange = range.slice();\n      restriction.range = new rangeConstructor(\n        startLine,\n        startCol,\n        endLine,\n        endCol,\n      );\n      restriction.index = index;\n      if (!restriction.allowMultiline) {\n        restriction.allowMultiline = rangeConstructor.spansMultipleLines(\n          restriction.range,\n        );\n      }\n      if (!restriction.label) {\n        restriction.label = `[${startLine},${startCol} -> ${endLine}${endCol}]`;\n      }\n    });\n  };\n  const getCurrentEditableRanges = function() {\n    return restrictions.reduce(function(acc, restriction) {\n      acc[restriction.label] = {\n        allowMultiline: restriction.allowMultiline || false,\n        index: restriction.index,\n        range: Object.assign({}, restriction.range),\n        originalRange: restriction._originalRange.slice(),\n      };\n      return acc;\n    }, {});\n  };\n  const getValueInEditableRanges = function() {\n    return restrictions.reduce(function(acc, restriction) {\n      acc[restriction.label] = model.getValueInRange(restriction.range);\n      return acc;\n    }, {});\n  };\n  const updateValueInEditableRanges = function(object, forceMoveMarkers) {\n    if (typeof object === 'object' && !Array.isArray(object)) {\n      forceMoveMarkers =\n        typeof forceMoveMarkers === 'boolean' ? forceMoveMarkers : false;\n      const restrictionsMap = restrictions.reduce(function(acc, restriction) {\n        if (restriction.label) {\n          acc[restriction.label] = restriction;\n        }\n        return acc;\n      }, {});\n      for (let label in object) {\n        const restriction = restrictionsMap[label];\n        if (restriction) {\n          const value = object[label];\n          if (doesChangeHasMultilineConflict(restriction, value)) {\n            throw new Error('Multiline change is not allowed for ' + label);\n          }\n          const newRange = deepClone(restriction.range);\n          newRange.endLine = newRange.startLine + value.split('\\n').length - 1;\n          newRange.endColumn = value.split('\\n').pop().length;\n          if (isChangeInvalidAsPerUser(restriction, value, newRange)) {\n            throw new Error(\n              'Change is invalidated by validate function of ' + label,\n            );\n          }\n          model.applyEdits([\n            {\n              forceMoveMarkers: !!forceMoveMarkers,\n              range: restriction.range,\n              text: value,\n            },\n          ]);\n        } else {\n          console.error('No restriction found for ' + label);\n        }\n      }\n    } else {\n      throw new Error('Value must be an object'); //No I18n\n    }\n  };\n  const disposeRestrictions = function() {\n    model._restrictionChangeListener.dispose();\n    window.removeEventListener('error', handleUnhandledPromiseRejection);\n    delete model.editInRestrictedArea;\n    delete model.disposeRestrictions;\n    delete model.getValueInEditableRanges;\n    delete model.updateValueInEditableRanges;\n    delete model.updateRestrictions;\n    delete model.getCurrentEditableRanges;\n    delete model.toggleHighlightOfEditableAreas;\n    delete model._hasHighlight;\n    delete model._isRestrictedModel;\n    delete model._isCursorAtCheckPoint;\n    delete model._currentCursorPositions;\n    delete model._editableRangeChangeListener;\n    delete model._restrictionChangeListener;\n    delete model._oldDecorations;\n    delete model._oldDecorationsSource;\n    return model;\n  };\n  const isCursorAtCheckPoint = function(positions) {\n    positions.some(function(position) {\n      const posLineNumber = position.lineNumber;\n      const posCol = position.column;\n      const length = restrictions.length;\n      for (let i = 0; i < length; i++) {\n        const range = restrictions[i].range;\n        if (\n          (range.startLineNumber === posLineNumber &&\n            range.startColumn === posCol) ||\n          (range.endLineNumber === posLineNumber && range.endColumn === posCol)\n        ) {\n          model.pushStackElement();\n          return true;\n        }\n      }\n    });\n  };\n  const addEditableRangeListener = function(callback) {\n    if (typeof callback === 'function') {\n      model._editableRangeChangeListener.push(callback);\n    }\n  };\n  const triggerChangeListenersWith = function(currentChanges, allChanges) {\n    const currentRanges = getCurrentEditableRanges();\n    model._editableRangeChangeListener.forEach(function(callback) {\n      callback.call(model, currentChanges, allChanges, currentRanges);\n    });\n  };\n  const doUndo = function() {\n    return Promise.resolve().then(function() {\n      model.editInRestrictedArea = true;\n      model.undo();\n      model.editInRestrictedArea = false;\n      if (model._hasHighlight && model._oldDecorationsSource) {\n        // id present in the decorations info will be omitted by monaco\n        // So we don't need to remove the old decorations id\n        model.deltaDecorations(\n          model._oldDecorations,\n          model._oldDecorationsSource,\n        );\n        model._oldDecorationsSource.forEach(function(object) {\n          object.range = model.getDecorationRange(object.id);\n        });\n      }\n    });\n  };\n  const updateRange = function(\n    restriction,\n    range,\n    finalLine,\n    finalColumn,\n    changes,\n    changeIndex,\n  ) {\n    let oldRangeEndLineNumber = range.endLineNumber;\n    let oldRangeEndColumn = range.endColumn;\n    restriction.prevRange = range;\n    restriction.range = range.setEndPosition(finalLine, finalColumn);\n    const length = restrictions.length;\n    let changesLength = changes.length;\n    const diffInCol = finalColumn - oldRangeEndColumn;\n    const diffInRow = finalLine - oldRangeEndLineNumber;\n\n    const cursorPositions = model._currentCursorPositions || [];\n    const noOfCursorPositions = cursorPositions.length;\n    // if (noOfCursorPositions > 0) {\n    if (changesLength !== noOfCursorPositions) {\n      changes = changes.filter(function(change) {\n        const range = change.range;\n        for (let i = 0; i < noOfCursorPositions; i++) {\n          const cursorPosition = cursorPositions[i];\n          if (\n            range.startLineNumber === cursorPosition.startLineNumber &&\n            range.endLineNumber === cursorPosition.endLineNumber &&\n            range.startColumn === cursorPosition.startColumn &&\n            range.endColumn === cursorPosition.endColumn\n          ) {\n            return true;\n          }\n        }\n        return false;\n      });\n      changesLength = changes.length;\n    }\n    if (diffInRow !== 0) {\n      for (let i = restriction.index + 1; i < length; i++) {\n        const nextRestriction = restrictions[i];\n        const nextRange = nextRestriction.range;\n        if (oldRangeEndLineNumber === nextRange.startLineNumber) {\n          nextRange.startColumn += diffInCol;\n        }\n        if (oldRangeEndLineNumber === nextRange.endLineNumber) {\n          nextRange.endColumn += diffInCol;\n        }\n        nextRange.startLineNumber += diffInRow;\n        nextRange.endLineNumber += diffInRow;\n        nextRestriction.range = nextRange;\n      }\n      for (let i = changeIndex + 1; i < changesLength; i++) {\n        const nextChange = changes[i];\n        const rangeInChange = nextChange.range;\n        const rangeAsString = rangeInChange.toString();\n        const rangeMapValue = rangeMap[rangeAsString];\n        delete rangeMap[rangeAsString];\n        if (oldRangeEndLineNumber === rangeInChange.startLineNumber) {\n          rangeInChange.startColumn += diffInCol;\n        }\n        if (oldRangeEndLineNumber === rangeInChange.endLineNumber) {\n          rangeInChange.endColumn += diffInCol;\n        }\n        rangeInChange.startLineNumber += diffInRow;\n        rangeInChange.endLineNumber += diffInRow;\n        nextChange.range = rangeInChange;\n        rangeMap[rangeInChange.toString()] = rangeMapValue;\n      }\n    } else {\n      // Only Column might have changed\n      for (let i = restriction.index + 1; i < length; i++) {\n        const nextRestriction = restrictions[i];\n        const nextRange = nextRestriction.range;\n        if (nextRange.startLineNumber > oldRangeEndLineNumber) {\n          break;\n        } else {\n          nextRange.startColumn += diffInCol;\n          nextRange.endColumn += diffInCol;\n          nextRestriction.range = nextRange;\n        }\n      }\n      for (let i = changeIndex + 1; i < changesLength; i++) {\n        // rangeMap\n        const nextChange = changes[i];\n        const rangeInChange = nextChange.range;\n        const rangeAsString = rangeInChange.toString();\n        const rangeMapValue = rangeMap[rangeAsString];\n        delete rangeMap[rangeAsString];\n        if (rangeInChange.startLineNumber > oldRangeEndLineNumber) {\n          rangeMap[rangeInChange.toString()] = rangeMapValue;\n          break;\n        } else {\n          rangeInChange.startColumn += diffInCol;\n          rangeInChange.endColumn += diffInCol;\n          nextChange.range = rangeInChange;\n          rangeMap[rangeInChange.toString()] = rangeMapValue;\n        }\n      }\n    }\n    // }\n  };\n  const getInfoFrom = function(change, editableRange) {\n    const info = {};\n    const range = change.range;\n    // Get State\n    if (change.text === '') {\n      info.isDeletion = true;\n    } else if (\n      range.startLineNumber === range.endLineNumber &&\n      range.startColumn === range.endColumn\n    ) {\n      info.isAddition = true;\n    } else {\n      info.isReplacement = true;\n    }\n    // Get Position Of Range\n    info.startLineOfRange =\n      range.startLineNumber === editableRange.startLineNumber;\n    info.startColumnOfRange = range.startColumn === editableRange.startColumn;\n\n    info.endLineOfRange = range.endLineNumber === editableRange.endLineNumber;\n    info.endColumnOfRange = range.endColumn === editableRange.endColumn;\n\n    info.middleLineOfRange = !info.startLineOfRange && !info.endLineOfRange;\n\n    // Editable Range Span\n    if (editableRange.startLineNumber === editableRange.endLineNumber) {\n      info.rangeIsSingleLine = true;\n    } else {\n      info.rangeIsMultiLine = true;\n    }\n    return info;\n  };\n  const updateRestrictions = function(ranges) {\n    restrictions = deepClone(ranges).sort(sortRangesInAscendingOrder);\n    prepareRestrictions(restrictions);\n  };\n  const toggleHighlightOfEditableAreas = function(cssClasses) {\n    if (!model._hasHighlight) {\n      const cssClassForSingleLine =\n        cssClasses.cssClassForSingleLine || enums.SINGLE_LINE_HIGHLIGHT_CLASS;\n      const cssClassForMultiLine =\n        cssClasses.cssClassForMultiLine || enums.MULTI_LINE_HIGHLIGHT_CLASS;\n      const cssClassForRestrictedArea =\n        cssClasses.cssClassForRestrictedArea ||\n        enums.RESTRICTED_AREA_HIGHLIGHT_CLASS;\n\n      const decorations = restrictions.map(function(restriction) {\n        const decoration = {\n          range: restriction.range,\n          options: {\n            className: restriction.allowMultiline\n              ? cssClassForMultiLine\n              : cssClassForSingleLine,\n          },\n        };\n        if (restriction.label) {\n          decoration.hoverMessage = restriction.label;\n        }\n        return decoration;\n      });\n      getEditorBoundaryExcludingBoundaryList(\n        model.getFullModelRange(),\n        restrictions.map(restriction => restriction.range),\n        model.getValue(),\n      ).forEach(range => {\n        decorations.push({\n          range,\n          options: {\n            className: cssClassForRestrictedArea,\n            stickiness: monaco.editor.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,\n          },\n          lable: 'Cannot Change this Section',\n        });\n      });\n      model._oldDecorations = model.deltaDecorations([], decorations);\n      model._oldDecorationsSource = decorations.map(function(\n        decoration,\n        index,\n      ) {\n        return Object.assign({}, decoration, {\n          id: model._oldDecorations[index],\n        });\n      });\n      model._hasHighlight = true;\n    } else {\n      model.deltaDecorations(model._oldDecorations, []);\n      delete model._oldDecorations;\n      delete model._oldDecorationsSource;\n      model._hasHighlight = false;\n    }\n  };\n  const handleUnhandledPromiseRejection = function() {\n    console.debug('handler for unhandled promise rejection');\n  };\n  const setAllRangesToPrev = function(rangeMap) {\n    for (let key in rangeMap) {\n      const restriction = rangeMap[key];\n      restriction.range = restriction.prevRange;\n    }\n  };\n  const doesChangeHasMultilineConflict = function(restriction, text) {\n    return !restriction.allowMultiline && text.includes('\\n');\n  };\n  const isChangeInvalidAsPerUser = function(restriction, value, range) {\n    return (\n      restriction.validate &&\n      !restriction.validate(value, range, restriction.lastInfo)\n    );\n  };\n\n  const manipulatorApi = {\n    _isRestrictedModel: true,\n    _isRestrictedValueValid: true,\n    _editableRangeChangeListener: [],\n    _isCursorAtCheckPoint: isCursorAtCheckPoint,\n    _currentCursorPositions: [],\n  };\n\n  prepareRestrictions(restrictions);\n  model._hasHighlight = false;\n  manipulatorApi._restrictionChangeListener = model.onDidChangeContent(function(\n    contentChangedEvent,\n  ) {\n    const isUndoing = contentChangedEvent.isUndoing;\n    model._isRestrictedValueValid = true;\n    if (!(isUndoing && model.editInRestrictedArea)) {\n      const changes = contentChangedEvent.changes.sort(\n        sortRangesInAscendingOrder,\n      );\n      const rangeMap = {};\n      const length = restrictions.length;\n      const isAllChangesValid = changes.every(function(change) {\n        const editedRange = change.range;\n        const rangeAsString = editedRange.toString();\n        rangeMap[rangeAsString] = null;\n        for (let i = 0; i < length; i++) {\n          const restriction = restrictions[i];\n          const range = restriction.range;\n          if (range.containsRange(editedRange)) {\n            if (doesChangeHasMultilineConflict(restriction, change.text)) {\n              return false;\n            }\n            rangeMap[rangeAsString] = restriction;\n            return true;\n          }\n        }\n        return false;\n      });\n      if (isAllChangesValid) {\n        changes.forEach(function(change, changeIndex) {\n          const changedRange = change.range;\n          const restriction = rangeMap[changedRange.toString()];\n          const editableRange = restriction.range;\n          const text = change.text || '';\n          /**\n           * Things to check before implementing the change\n           * - A | D | R => Addition | Deletion | Replacement\n           * - MC | SC => MultiLineChange | SingleLineChange\n           * - SOR | MOR | EOR => Change Occured in - Start Of Range | Middle Of Range | End Of Range\n           * - SSL | SML => Editable Range - Spans Single Line | Spans Multiple Line\n           */\n          const noOfLinesAdded = (text.match(/\\n/g) || []).length;\n          const noOfColsAddedAtLastLine = text.split(/\\n/g).pop().length;\n\n          const lineDiffInRange =\n            changedRange.endLineNumber - changedRange.startLineNumber;\n          const colDiffInRange =\n            changedRange.endColumn - changedRange.startColumn;\n\n          let finalLine = editableRange.endLineNumber;\n          let finalColumn = editableRange.endColumn;\n\n          let columnsCarriedToEnd = 0;\n          if (\n            editableRange.endLineNumber === changedRange.startLineNumber ||\n            editableRange.endLineNumber === changedRange.endLineNumber\n          ) {\n            columnsCarriedToEnd +=\n              editableRange.endColumn - changedRange.startColumn + 1;\n          }\n\n          const info = getInfoFrom(change, editableRange);\n          restriction.lastInfo = info;\n          if (info.isAddition || info.isReplacement) {\n            if (info.rangeIsSingleLine) {\n              /**\n               * Only Column Change has occurred , so regardless of the position of the change\n               * Addition of noOfCols is enough\n               */\n              if (noOfLinesAdded === 0) {\n                finalColumn += noOfColsAddedAtLastLine;\n              } else {\n                finalLine += noOfLinesAdded;\n                if (info.startColumnOfRange) {\n                  finalColumn += noOfColsAddedAtLastLine;\n                } else if (info.endColumnOfRange) {\n                  finalColumn = noOfColsAddedAtLastLine + 1;\n                } else {\n                  finalColumn = noOfColsAddedAtLastLine + columnsCarriedToEnd;\n                }\n              }\n            }\n            if (info.rangeIsMultiLine) {\n              // Handling for Start Of Range is not required\n              finalLine += noOfLinesAdded;\n              if (info.endLineOfRange) {\n                if (noOfLinesAdded === 0) {\n                  finalColumn += noOfColsAddedAtLastLine;\n                } else {\n                  finalColumn = columnsCarriedToEnd + noOfColsAddedAtLastLine;\n                }\n              }\n            }\n          }\n          if (info.isDeletion || info.isReplacement) {\n            if (info.rangeIsSingleLine) {\n              finalColumn -= colDiffInRange;\n            }\n            if (info.rangeIsMultiLine) {\n              if (info.endLineOfRange) {\n                finalLine -= lineDiffInRange;\n                finalColumn -= colDiffInRange;\n              } else {\n                finalLine -= lineDiffInRange;\n              }\n            }\n          }\n          updateRange(\n            restriction,\n            editableRange,\n            finalLine,\n            finalColumn,\n            changes,\n            changeIndex,\n          );\n        });\n        const values = model.getValueInEditableRanges();\n        const currentlyEditedRanges = {};\n        for (let key in rangeMap) {\n          const restriction = rangeMap[key];\n          const range = restriction.range;\n          const rangeString = restriction.label || range.toString();\n          const value = values[rangeString];\n          if (isChangeInvalidAsPerUser(restriction, value, range)) {\n            setAllRangesToPrev(rangeMap);\n            doUndo();\n            return; // Breaks the loop and prevents the triggerChangeListener\n          }\n          currentlyEditedRanges[rangeString] = value;\n        }\n        if (model._hasHighlight) {\n          model._oldDecorationsSource.forEach(function(object) {\n            object.range = model.getDecorationRange(object.id);\n          });\n        }\n        triggerChangeListenersWith(currentlyEditedRanges, values);\n      } else {\n        doUndo();\n      }\n    } else if (model.editInRestrictedArea) {\n      model._isRestrictedValueValid = false;\n    }\n  });\n  window.onerror = handleUnhandledPromiseRejection;\n  const exposedApi = {\n    editInRestrictedArea: false,\n    getCurrentEditableRanges: getCurrentEditableRanges,\n    getValueInEditableRanges: getValueInEditableRanges,\n    disposeRestrictions: disposeRestrictions,\n    onDidChangeContentInEditableRange: addEditableRangeListener,\n    updateRestrictions: updateRestrictions,\n    updateValueInEditableRanges: updateValueInEditableRanges,\n    toggleHighlightOfEditableAreas: toggleHighlightOfEditableAreas,\n  };\n  for (let funcName in manipulatorApi) {\n    Object.defineProperty(model, funcName, {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: manipulatorApi[funcName],\n    });\n  }\n  for (let apiName in exposedApi) {\n    Object.defineProperty(model, apiName, {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: exposedApi[apiName],\n    });\n  }\n  return model;\n};\nexport default constrainedModel;\n","export const getEditorBoundaryExcludingBoundaryList = (\n  editorBoundary,\n  boundaryList,\n  content,\n) => {\n  const finalBoundaryList = [];\n  const lastBoundaryDetails = editorBoundary;\n  const contentValue = content.split('\\n');\n  boundaryList.forEach((boundary, index) => {\n    if (\n      boundary.startLineNumber > lastBoundaryDetails.startLineNumber ||\n      (boundary.startLineNumber === lastBoundaryDetails.startLineNumber &&\n        boundary.startColumn > lastBoundaryDetails.startColumn)\n    ) {\n      let newEndRow = boundary.startLineNumber;\n      let newEndColumn = boundary.startColumn - 1;\n\n      if (boundary.startColumn === 1) {\n        newEndRow = boundary.startLineNumber - 1;\n        newEndColumn =\n          (contentValue[boundary.startLineNumber - 2]?.length || 0) + 1;\n      }\n      finalBoundaryList.push({\n        startLineNumber: lastBoundaryDetails.startLineNumber,\n        startColumn: lastBoundaryDetails.startColumn,\n        endLineNumber: newEndRow,\n        endColumn: newEndColumn,\n      });\n    }\n    let newStartRow = boundary.endLineNumber;\n    let newStartColumn = boundary.endColumn;\n\n    if (contentValue[newStartRow - 2]?.length === 0) {\n      newStartRow = boundary.startLineNumber + 1;\n      newStartColumn = (contentValue[newStartRow - 1]?.length || 0) + 1;\n    }\n    lastBoundaryDetails.startLineNumber = newStartRow;\n    lastBoundaryDetails.startColumn = newStartColumn;\n\n    if (\n      index === boundaryList.length - 1 &&\n      (boundary.endLineNumber !== lastBoundaryDetails.endLineNumber ||\n        boundary.endColumn !== lastBoundaryDetails.endColumn)\n    ) {\n      finalBoundaryList.push({\n        startLineNumber: lastBoundaryDetails.startLineNumber,\n        startColumn: lastBoundaryDetails.startColumn,\n        endLineNumber: lastBoundaryDetails.endLineNumber,\n        endColumn: lastBoundaryDetails.endColumn,\n      });\n    }\n  });\n  return finalBoundaryList;\n};\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","monaco","dummyDiv","document","createElement","dummyEditorInstance","editor","create","editorInstanceConstructorName","constructor","name","editorModelConstructorName","getModel","isInstanceValid","valueToValidate","isModelValid","isRangesValid","ranges","Array","isArray","every","rangeObj","range","length","num","parseInt","allowMultiline","label","validate","TypeMustBe","type","additional","join","byPassPrimitives","value","callback","this","freeze","Date","cloneArray","array","keys","arrayClone","i","cloner","object","clone","withProto","config","constructOptionForCode","reduce","acc","option","bind","codes","defineProperties","methods","andFreeze","withProtoAndFreeze","API","methodName","writable","configurable","undefined","Error","listenerFn","editorInstance","model","_isCursorAtCheckPoint","selections","getSelections","positions","map","selection","lineNumber","positionLineNumber","column","positionColumn","_currentCursorPositions","_uriRestrictionMap","manipulator","_listener","_editorInstance","_injectedResources","exposedMethods","initializeIn","domNode","getDomNode","_isInDevMode","addEventListener","_onChangeModelDisposable","onDidChangeModel","removeEventListener","newDomNode","addRestrictionsTo","modelToConstrain","rangeConstructor","Range","sortRangesInAscendingOrder","rangeObject1","rangeObject2","rangeA","rangeB","restrictions","sort","prepareRestrictions","content","getValue","forEach","restriction","index","lines","split","noOfLines","normalizedRange","actualStartCol","startLineNo","maxCols","Math","abs","actualEndLine","console","warn","actualEndCol","endLineNo","normalizeRange","startLine","startCol","endLine","endCol","_originalRange","slice","spansMultipleLines","getCurrentEditableRanges","assign","originalRange","doUndo","Promise","resolve","then","editInRestrictedArea","undo","_hasHighlight","_oldDecorationsSource","deltaDecorations","_oldDecorations","getDecorationRange","id","updateRange","finalLine","finalColumn","changes","changeIndex","oldRangeEndLineNumber","endLineNumber","oldRangeEndColumn","endColumn","prevRange","setEndPosition","changesLength","diffInCol","diffInRow","cursorPositions","noOfCursorPositions","filter","change","cursorPosition","startLineNumber","startColumn","nextRestriction","nextRange","nextChange","rangeInChange","rangeAsString","toString","rangeMapValue","rangeMap","handleUnhandledPromiseRejection","debug","setAllRangesToPrev","doesChangeHasMultilineConflict","text","includes","isChangeInvalidAsPerUser","lastInfo","manipulatorApi","_isRestrictedModel","_isRestrictedValueValid","_editableRangeChangeListener","some","position","posLineNumber","posCol","pushStackElement","_restrictionChangeListener","onDidChangeContent","contentChangedEvent","isUndoing","editedRange","containsRange","changedRange","editableRange","noOfLinesAdded","match","noOfColsAddedAtLastLine","pop","lineDiffInRange","colDiffInRange","columnsCarriedToEnd","info","isDeletion","isAddition","isReplacement","startLineOfRange","startColumnOfRange","endLineOfRange","endColumnOfRange","middleLineOfRange","rangeIsSingleLine","rangeIsMultiLine","getInfoFrom","values","getValueInEditableRanges","currentlyEditedRanges","rangeString","currentChanges","allChanges","currentRanges","triggerChangeListenersWith","window","onerror","exposedApi","getValueInRange","disposeRestrictions","dispose","updateValueInEditableRanges","updateRestrictions","toggleHighlightOfEditableAreas","onDidChangeContentInEditableRange","push","forceMoveMarkers","restrictionsMap","newRange","applyEdits","error","cssClasses","cssClassForSingleLine","cssClassForMultiLine","cssClassForRestrictedArea","decorations","decoration","options","className","hoverMessage","editorBoundary","boundaryList","finalBoundaryList","lastBoundaryDetails","contentValue","boundary","newEndRow","newEndColumn","newStartRow","newStartColumn","getEditorBoundaryExcludingBoundaryList","getFullModelRange","stickiness","TrackedRangeStickiness","NeverGrowsWhenTypingAtEdges","lable","funcName","apiName","uri","removeRestrictionsIn","restrictedModel","disposeConstrainer","_devModeAction","toggleDevMode","addAction","contextMenuGroupId","contextMenuOrder","run","JSON","stringify","log"],"sourceRoot":""}