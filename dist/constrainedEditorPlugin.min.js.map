{"version":3,"file":"constrainedEditorPlugin.min.js","mappings":"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","sources":["webpack://constrainedEditor/webpack/bootstrap","webpack://constrainedEditor/webpack/runtime/define property getters","webpack://constrainedEditor/webpack/runtime/hasOwnProperty shorthand","webpack://constrainedEditor/./src/utils/validators.js","webpack://constrainedEditor/./src/utils/definedErrors.js","webpack://constrainedEditor/./src/utils/boundaryUtils.js","webpack://constrainedEditor/./src/utils/deepClone.js","webpack://constrainedEditor/./src/utils/enums.js","webpack://constrainedEditor/./src/constrainedEditor.js","webpack://constrainedEditor/./src/constrainedModel.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const validators = {\n  initWith: function (monaco) {\n    const dummyDiv = document.createElement('div');\n    const dummyEditorInstance = monaco.editor.create(dummyDiv);\n    const editorInstanceConstructorName = dummyEditorInstance.constructor.name;\n    const editorModelConstructorName = dummyEditorInstance.getModel().constructor.name;\n    const instanceCheck = function (valueToValidate) {\n      return valueToValidate.constructor.name === editorInstanceConstructorName;\n    }\n    const modelCheck = function (valueToValidate) {\n      return valueToValidate.constructor.name === editorModelConstructorName;\n    }\n    const rangesCheck = function (ranges) {\n      if (Array.isArray(ranges)) {\n        return ranges.every(function (rangeObj) {\n          if (typeof rangeObj === 'object' && rangeObj.constructor.name === 'Object') {\n            if (!rangeObj.hasOwnProperty('range')) return false;\n            if (!Array.isArray(rangeObj.range)) return false;\n            if (rangeObj.range.length !== 4) return false;\n            if (!(rangeObj.range.every(num => num > 0 && parseInt(num) === num))) return false;\n            if (rangeObj.hasOwnProperty('allowMultiline')) {\n              if (typeof rangeObj.allowMultiline !== 'boolean') return false;\n            }\n            if (rangeObj.hasOwnProperty('label')) {\n              if (typeof rangeObj.label !== 'string') return false;\n            }\n            if (rangeObj.hasOwnProperty('validate')) {\n              if (typeof rangeObj.validate !== 'function') return false;\n            }\n            return true;\n          }\n          return false;\n        });\n      }\n      return false;\n    }\n    return {\n      isInstanceValid: instanceCheck,\n      isModelValid: modelCheck,\n      isRangesValid: rangesCheck\n    }\n  }\n}\nexport default validators;","export const TypeMustBe = function (type, key, additional) {\n  return 'The value for the ' + key + ' should be of type ' + (Array.isArray(type) ? type.join(' | ') : type) + '. ' + (additional || '')\n}\nconst definedErrors = {\n  TypeMustBe : TypeMustBe\n};\nexport default definedErrors;","export const getEditorBoundaryExcludingBoundaryList = (\n  editorBoundary,\n  boundaryList\n) => {\n  const finalBoundaryList = [];\n  const lastBoundaryDetails = editorBoundary;\n  boundaryList.forEach((boundary, index) => {\n    if (\n      boundary.startLineNumber > lastBoundaryDetails.startLineNumber ||\n      (boundary.startLineNumber === lastBoundaryDetails.startLineNumber &&\n        boundary.startColumn > lastBoundaryDetails.startColumn)\n    ) {\n      finalBoundaryList.push([\n        lastBoundaryDetails.startLineNumber,\n        lastBoundaryDetails.startColumn,\n        boundary.startLineNumber,\n        boundary.startColumn,\n      ]);\n    }\n    if (\n      index === boundaryList.length - 1 &&\n      (boundary.endLineNumber !== lastBoundaryDetails.endLineNumber ||\n        boundary.endColumn !== lastBoundaryDetails.endColumn)\n    ) {\n      finalBoundaryList.push([\n        boundary.endLineNumber,\n        boundary.endColumn,\n        lastBoundaryDetails.endLineNumber,\n        lastBoundaryDetails.endColumn,\n        ,\n      ]);\n    }\n    lastBoundaryDetails.startLineNumber = boundary.endLineNumber;\n    lastBoundaryDetails.startColumn = boundary.endColumn    ;\n  });\n  return finalBoundaryList;\n};\n","export const deepClone = (function () {\n  const byPassPrimitives = function (value, callback) {\n    if (typeof value !== 'object' || value === null) {\n      return this.freeze ? Object.freeze(value) : value;\n    }\n    if (value instanceof Date) {\n      return this.freeze ? Object.freeze(new Date(value)) : new Date(value);\n    }\n    return callback.call(this, value);\n  }\n  const cloneArray = function (array, callback) {\n    const keys = Object.keys(array);\n    const arrayClone = new Array(keys.length)\n    for (let i = 0; i < keys.length; i++) {\n      arrayClone[keys[i]] = byPassPrimitives.call(this, array[keys[i]], callback);\n    }\n    return arrayClone;\n  }\n  const cloner = function (object) {\n    return byPassPrimitives.call(this, object, function (object) {\n      if (Array.isArray(object)) {\n        return cloneArray.call(this, object, cloner)\n      }\n      const clone = {};\n      for (let key in object) {\n        if (!this.withProto && Object.hasOwnProperty.call(object, key) === false) {\n          continue;\n        }\n        clone[key] = byPassPrimitives.call(this, object[key], cloner);\n      }\n      return clone;\n    })\n  }\n  const config = (function () {\n    const constructOptionForCode = function (value) {\n      const options = [\n        'withProto',\n        'freeze'\n      ]\n      this[value] = options.reduce(function (acc, option) {\n        if (acc[option] = (value >= this[option])) {\n          value -= this[option]\n        }\n        return acc;\n      }.bind(this), {})\n    }\n    const codes = Object.create(Object.defineProperties({}, {\n      withProto: { value: 1 },\n      freeze: { value: 2 }\n    }));\n    for (let i = 0; i <= 3; i++) {\n      constructOptionForCode.call(codes, i);\n    }\n    return codes;\n  }());\n  const methods = {\n    withProto: cloner.bind(config[1]),\n    andFreeze: cloner.bind(config[2]),\n    withProtoAndFreeze: cloner.bind(config[3])\n  }\n  const API = cloner.bind(config[0]);\n  for (let methodName in methods) {\n    Object.defineProperty(API, methodName, {\n      enumerable: false,\n      writable: false,\n      configurable: false,\n      value: methods[methodName]\n    })\n  }\n  return API;\n}());\n\nexport default deepClone;","export const enums = {\n  SINGLE_LINE_HIGHLIGHT_CLASS: 'editableArea--single-line',\n  MULTI_LINE_HIGHLIGHT_CLASS: 'editableArea--multi-line',\n  RESTRICTED_AREA_HIGHLIGHT_CLASS: 'editableArea--restricted',\n  \n}\nexport default enums;","import validators from './utils/validators.js';\nimport { TypeMustBe } from './utils/definedErrors.js';\nimport constrainedModel from './constrainedModel.js';\n\nexport function constrainedEditor(monaco) {\n  /**\n   * Injected Dependencies\n   */\n  if (monaco === undefined) {\n    throw new Error([\n      \"Please pass the monaco global variable into function as\",\n      \"(eg:)constrainedEditor({ range : monaco.range });\",\n    ].join('\\n'));\n  }\n  /**\n   *\n   * @param {Object} editorInstance This should be the monaco editor instance.\n   * @description This is the listener function to check whether the cursor is at checkpoints\n   * (i.e) the point where editable and non editable portions meet\n   */\n  const listenerFn = function (editorInstance) {\n    const model = editorInstance.getModel();\n    if (model._isCursorAtCheckPoint) {\n      const selections = editorInstance.getSelections();\n      const positions = selections.map(function (selection) {\n        return {\n          lineNumber: selection.positionLineNumber,\n          column: selection.positionColumn\n        }\n      });\n      model._isCursorAtCheckPoint(positions);\n      model._currentCursorPositions = selections;\n    }\n  }\n  const _uriRestrictionMap = {};\n  const { isInstanceValid, isModelValid, isRangesValid } = validators.initWith(monaco);\n  /**\n   *\n   * @param {Object} editorInstance This should be the monaco editor instance\n   * @returns {Boolean}\n   */\n  const initInEditorInstance = function (editorInstance) {\n    if (isInstanceValid(editorInstance)) {\n      let domNode = editorInstance.getDomNode();\n      manipulator._listener = listenerFn.bind(API, editorInstance);\n      manipulator._editorInstance = editorInstance;\n      manipulator._editorInstance._isInDevMode = false;\n      domNode.addEventListener('keydown', manipulator._listener, true);\n      manipulator._onChangeModelDisposable = editorInstance.onDidChangeModel(function () {\n        // domNode - refers old dom node\n        domNode && domNode.removeEventListener('keydown', manipulator._listener, true)\n        const newDomNode = editorInstance.getDomNode(); // Gets Current dom node\n        newDomNode && newDomNode.addEventListener('keydown', manipulator._listener, true);\n        domNode = newDomNode;\n      })\n      return true;\n    } else {\n      throw new Error(\n        TypeMustBe(\n          'ICodeEditor',\n          'editorInstance',\n          'This type interface can be found in monaco editor documentation'\n        )\n      )\n    }\n  }\n  /**\n   *\n   * @param {Object} model This should be the monaco editor model instance. Refer https://microsoft.github.io/monaco-editor/api/interfaces/monaco.editor.itextmodel.html\n   * @param {*} ranges This should be the array of range objects. Refer constrained editor plugin documentation\n   * @returns model\n   */\n  const addRestrictionsTo = function (model, ranges) {\n    if (isModelValid(model)) {\n      if (isRangesValid(ranges)) {\n        const modelToConstrain = constrainedModel(model, ranges, monaco, manipulator._editorInstance);\n        _uriRestrictionMap[modelToConstrain.uri.toString()] = modelToConstrain;\n        return modelToConstrain;\n      } else {\n        throw new Error(\n          TypeMustBe(\n            'Array<RangeRestrictionObject>',\n            'ranges',\n            'Please refer constrained editor documentation for proper structure'\n          )\n        )\n      }\n    } else {\n      throw new Error(\n        TypeMustBe(\n          'ICodeEditor',\n          'editorInstance',\n          'This type interface can be found in monaco editor documentation'\n        )\n      )\n    }\n  }\n  /**\n   *\n   * @param {Object} model This should be the monaco editor model instance. Refer https://microsoft.github.io/monaco-editor/api/interfaces/monaco.editor.itextmodel.html\n   * @returns {Boolean} True if the restrictions are removed\n   */\n  const removeRestrictionsIn = function (model) {\n    if (isModelValid(model)) {\n      const uri = model.uri.toString();\n      const restrictedModel = _uriRestrictionMap[uri];\n      if (restrictedModel) {\n        return restrictedModel.disposeRestrictions();\n      } else {\n        console.warn('Current Model is not a restricted Model');\n        return false;\n      }\n    } else {\n      throw new Error(\n        TypeMustBe(\n          'ICodeEditor',\n          'editorInstance',\n          'This type interface can be found in monaco editor documentation'\n        )\n      )\n    }\n  }\n  /**\n   *\n   * @returns {Boolean} True if the constrainer is disposed\n   */\n  const disposeConstrainer = function () {\n    if (manipulator._editorInstance) {\n      const instance = manipulator._editorInstance;\n      const domNode = instance.getDomNode();\n      domNode && domNode.removeEventListener('keydown', manipulator._listener);\n      manipulator._onChangeModelDisposable && manipulator._onChangeModelDisposable.dispose();\n      delete manipulator._listener;\n      delete manipulator._editorInstance._isInDevMode;\n      delete manipulator._editorInstance._devModeAction;\n      delete manipulator._editorInstance;\n      delete manipulator._onChangeModelDisposable;\n      for (let key in _uriRestrictionMap) {\n        delete _uriRestrictionMap[key];\n      }\n      return true;\n    }\n    return false;\n  }\n  /**\n   * @description This function used to make the developer to find the ranges of selected portions\n   */\n  const toggleDevMode = function () {\n    if (manipulator._editorInstance._isInDevMode) {\n      manipulator._editorInstance._isInDevMode = false;\n      manipulator._editorInstance._devModeAction.dispose();\n      delete manipulator._editorInstance._devModeAction;\n    } else {\n      manipulator._editorInstance._isInDevMode = true;\n      manipulator._editorInstance._devModeAction = manipulator._editorInstance.addAction({\n        id: 'showRange',\n        label: 'Show Range in console',\n        contextMenuGroupId: 'navigation',\n        contextMenuOrder: 1.5,\n        run: function (editor) {\n          const selections = editor.getSelections();\n          const ranges = selections.reduce(function (acc, { startLineNumber, endLineNumber, startColumn, endColumn }) {\n            acc.push('range : ' + JSON.stringify([\n              startLineNumber,\n              startColumn,\n              endLineNumber,\n              endColumn\n            ]));\n            return acc;\n          }, []).join('\\n');\n          console.log(`Selected Ranges : \\n` + JSON.stringify(ranges, null, 2));\n        }\n      });\n    }\n  }\n\n  /**\n   * Main Function starts here\n   */\n  // @internal\n  const manipulator = {\n    /**\n     * These variables should not be modified by external code\n     * This has to be used for debugging and testing\n     */\n    _listener: null,\n    _editorInstance: null,\n    _uriRestrictionMap: _uriRestrictionMap,\n    _injectedResources: monaco\n  }\n  const API = Object.create(manipulator);\n  const exposedMethods = {\n    /**\n     * These functions are exposed to the user\n     * These functions should be protected from editing\n     */\n    initializeIn: initInEditorInstance,\n    addRestrictionsTo: addRestrictionsTo,\n    removeRestrictionsIn: removeRestrictionsIn,\n    disposeConstrainer: disposeConstrainer,\n    toggleDevMode: toggleDevMode\n  }\n  for (let methodName in exposedMethods) {\n    Object.defineProperty(API, methodName, {\n      enumerable: false,\n      writable: false,\n      configurable: false,\n      value: exposedMethods[methodName]\n    })\n  }\n  return Object.freeze(API);\n}\n\nexport default constrainedEditor;\n","import { getEditorBoundaryExcludingBoundaryList } from \"./utils/boundaryUtils.js\";\nimport deepClone from \"./utils/deepClone.js\";\nimport enums from \"./utils/enums.js\";\nexport const constrainedModel = function (model, ranges, monaco) {\n  const rangeConstructor = monaco.Range;\n  const sortRangesInAscendingOrder = function (rangeObject1, rangeObject2) {\n    const rangeA = rangeObject1.range;\n    const rangeB = rangeObject2.range;\n    if (\n      rangeA[0] < rangeB[0] ||\n      (rangeA[0] === rangeB[0] && rangeA[3] < rangeB[1])\n    ) {\n      return -1;\n    }\n  };\n  const normalizeRange = function (range, content) {\n    const lines = content.split(\"\\n\");\n    const noOfLines = lines.length;\n    const normalizedRange = [];\n    range.forEach(function (value, index) {\n      if (value === 0) {\n        throw new Error(\"Range values cannot be zero\"); //No I18n\n      }\n      switch (index) {\n        case 0:\n          {\n            if (value < 0) {\n              throw new Error(\"Start Line of Range cannot be negative\"); //No I18n\n            } else if (value > noOfLines) {\n              throw new Error(\n                \"Provided Start Line(\" +\n                  value +\n                  \") is out of bounds. Max Lines in content is \" +\n                  noOfLines\n              ); //No I18n\n            }\n            normalizedRange[index] = value;\n          }\n          break;\n        case 1:\n          {\n            let actualStartCol = value;\n            const startLineNo = normalizedRange[0];\n            const maxCols = lines[startLineNo - 1].length;\n            if (actualStartCol < 0) {\n              actualStartCol = maxCols - Math.abs(actualStartCol);\n              if (actualStartCol < 0) {\n                throw new Error(\n                  \"Provided Start Column(\" +\n                    value +\n                    \") is out of bounds. Max Column in line \" +\n                    startLineNo +\n                    \" is \" +\n                    maxCols\n                ); //No I18n\n              }\n            } else if (actualStartCol > maxCols + 1) {\n              throw new Error(\n                \"Provided Start Column(\" +\n                  value +\n                  \") is out of bounds. Max Column in line \" +\n                  startLineNo +\n                  \" is \" +\n                  maxCols\n              ); //No I18n\n            }\n            normalizedRange[index] = actualStartCol;\n          }\n          break;\n        case 2:\n          {\n            let actualEndLine = value;\n            if (actualEndLine < 0) {\n              actualEndLine = noOfLines - Math.abs(value);\n              if (actualEndLine < 0) {\n                throw new Error(\n                  \"Provided End Line(\" +\n                    value +\n                    \") is out of bounds. Max Lines in content is \" +\n                    noOfLines\n                ); //No I18n\n              }\n              if (actualEndLine < normalizedRange[0]) {\n                console.warn(\n                  \"Provided End Line(\" +\n                    value +\n                    \") is less than the start Line, the Restriction may not behave as expected\"\n                ); //No I18n\n              }\n            } else if (value > noOfLines) {\n              throw new Error(\n                \"Provided End Line(\" +\n                  value +\n                  \") is out of bounds. Max Lines in content is \" +\n                  noOfLines\n              ); //No I18n\n            }\n            normalizedRange[index] = actualEndLine;\n          }\n          break;\n        case 3:\n          {\n            let actualEndCol = value;\n            const endLineNo = normalizedRange[2];\n            const maxCols = lines[endLineNo - 1].length;\n            if (actualEndCol < 0) {\n              actualEndCol = maxCols - Math.abs(actualEndCol);\n              if (actualEndCol < 0) {\n                throw new Error(\n                  \"Provided End Column(\" +\n                    value +\n                    \") is out of bounds. Max Column in line \" +\n                    endLineNo +\n                    \" is \" +\n                    maxCols\n                ); //No I18n\n              }\n            } else if (actualEndCol > maxCols + 1) {\n              throw new Error(\n                \"Provided Start Column(\" +\n                  value +\n                  \") is out of bounds. Max Column in line \" +\n                  endLineNo +\n                  \" is \" +\n                  maxCols\n              ); //No I18n\n            }\n            normalizedRange[index] = actualEndCol;\n          }\n          break;\n      }\n    });\n    return normalizedRange;\n  };\n  let restrictions = deepClone(ranges).sort(sortRangesInAscendingOrder);\n  const prepareRestrictions = function (restrictions) {\n    const content = model.getValue();\n    restrictions.forEach(function (restriction, index) {\n      const range = normalizeRange(restriction.range, content);\n      const startLine = range[0];\n      const startCol = range[1];\n      const endLine = range[2];\n      const endCol = range[3];\n      restriction._originalRange = range.slice();\n      restriction.range = new rangeConstructor(\n        startLine,\n        startCol,\n        endLine,\n        endCol\n      );\n      restriction.index = index;\n      if (!restriction.allowMultiline) {\n        restriction.allowMultiline = rangeConstructor.spansMultipleLines(\n          restriction.range\n        );\n      }\n      if (!restriction.label) {\n        restriction.label = `[${startLine},${startCol} -> ${endLine}${endCol}]`;\n      }\n    });\n  };\n  const getCurrentEditableRanges = function () {\n    return restrictions.reduce(function (acc, restriction) {\n      acc[restriction.label] = {\n        allowMultiline: restriction.allowMultiline || false,\n        index: restriction.index,\n        range: Object.assign({}, restriction.range),\n        originalRange: restriction._originalRange.slice(),\n      };\n      return acc;\n    }, {});\n  };\n  const getValueInEditableRanges = function () {\n    return restrictions.reduce(function (acc, restriction) {\n      acc[restriction.label] = model.getValueInRange(restriction.range);\n      return acc;\n    }, {});\n  };\n  const updateValueInEditableRanges = function (object, forceMoveMarkers) {\n    if (typeof object === \"object\" && !Array.isArray(object)) {\n      forceMoveMarkers =\n        typeof forceMoveMarkers === \"boolean\" ? forceMoveMarkers : false;\n      const restrictionsMap = restrictions.reduce(function (acc, restriction) {\n        if (restriction.label) {\n          acc[restriction.label] = restriction;\n        }\n        return acc;\n      }, {});\n      for (let label in object) {\n        const restriction = restrictionsMap[label];\n        if (restriction) {\n          const value = object[label];\n          if (doesChangeHasMultilineConflict(restriction, value)) {\n            throw new Error(\"Multiline change is not allowed for \" + label);\n          }\n          const newRange = deepClone(restriction.range);\n          newRange.endLine = newRange.startLine + value.split(\"\\n\").length - 1;\n          newRange.endColumn = value.split(\"\\n\").pop().length;\n          if (isChangeInvalidAsPerUser(restriction, value, newRange)) {\n            throw new Error(\n              \"Change is invalidated by validate function of \" + label\n            );\n          }\n          model.applyEdits([\n            {\n              forceMoveMarkers: !!forceMoveMarkers,\n              range: restriction.range,\n              text: value,\n            },\n          ]);\n        } else {\n          console.error(\"No restriction found for \" + label);\n        }\n      }\n    } else {\n      throw new Error(\"Value must be an object\"); //No I18n\n    }\n  };\n  const disposeRestrictions = function () {\n    model._restrictionChangeListener.dispose();\n    window.removeEventListener(\"error\", handleUnhandledPromiseRejection);\n    delete model.editInRestrictedArea;\n    delete model.disposeRestrictions;\n    delete model.getValueInEditableRanges;\n    delete model.updateValueInEditableRanges;\n    delete model.updateRestrictions;\n    delete model.getCurrentEditableRanges;\n    delete model.toggleHighlightOfEditableAreas;\n    delete model._hasHighlight;\n    delete model._isRestrictedModel;\n    delete model._isCursorAtCheckPoint;\n    delete model._currentCursorPositions;\n    delete model._editableRangeChangeListener;\n    delete model._restrictionChangeListener;\n    delete model._oldDecorations;\n    delete model._oldDecorationsSource;\n    return model;\n  };\n  const isCursorAtCheckPoint = function (positions) {\n    positions.some(function (position) {\n      const posLineNumber = position.lineNumber;\n      const posCol = position.column;\n      const length = restrictions.length;\n      for (let i = 0; i < length; i++) {\n        const range = restrictions[i].range;\n        if (\n          (range.startLineNumber === posLineNumber &&\n            range.startColumn === posCol) ||\n          (range.endLineNumber === posLineNumber && range.endColumn === posCol)\n        ) {\n          model.pushStackElement();\n          return true;\n        }\n      }\n    });\n  };\n  const addEditableRangeListener = function (callback) {\n    if (typeof callback === \"function\") {\n      model._editableRangeChangeListener.push(callback);\n    }\n  };\n  const triggerChangeListenersWith = function (currentChanges, allChanges) {\n    const currentRanges = getCurrentEditableRanges();\n    model._editableRangeChangeListener.forEach(function (callback) {\n      callback.call(model, currentChanges, allChanges, currentRanges);\n    });\n  };\n  const doUndo = function () {\n    return Promise.resolve().then(function () {\n      model.editInRestrictedArea = true;\n      model.undo();\n      model.editInRestrictedArea = false;\n      if (model._hasHighlight && model._oldDecorationsSource) {\n        // id present in the decorations info will be omitted by monaco\n        // So we don't need to remove the old decorations id\n        model.deltaDecorations(\n          model._oldDecorations,\n          model._oldDecorationsSource\n        );\n        model._oldDecorationsSource.forEach(function (object) {\n          object.range = model.getDecorationRange(object.id);\n        });\n      }\n    });\n  };\n  const updateRange = function (\n    restriction,\n    range,\n    finalLine,\n    finalColumn,\n    changes,\n    changeIndex\n  ) {\n    let oldRangeEndLineNumber = range.endLineNumber;\n    let oldRangeEndColumn = range.endColumn;\n    restriction.prevRange = range;\n    restriction.range = range.setEndPosition(finalLine, finalColumn);\n    const length = restrictions.length;\n    let changesLength = changes.length;\n    const diffInCol = finalColumn - oldRangeEndColumn;\n    const diffInRow = finalLine - oldRangeEndLineNumber;\n\n    const cursorPositions = model._currentCursorPositions || [];\n    const noOfCursorPositions = cursorPositions.length;\n    // if (noOfCursorPositions > 0) {\n    if (changesLength !== noOfCursorPositions) {\n      changes = changes.filter(function (change) {\n        const range = change.range;\n        for (let i = 0; i < noOfCursorPositions; i++) {\n          const cursorPosition = cursorPositions[i];\n          if (\n            range.startLineNumber === cursorPosition.startLineNumber &&\n            range.endLineNumber === cursorPosition.endLineNumber &&\n            range.startColumn === cursorPosition.startColumn &&\n            range.endColumn === cursorPosition.endColumn\n          ) {\n            return true;\n          }\n        }\n        return false;\n      });\n      changesLength = changes.length;\n    }\n    if (diffInRow !== 0) {\n      for (let i = restriction.index + 1; i < length; i++) {\n        const nextRestriction = restrictions[i];\n        const nextRange = nextRestriction.range;\n        if (oldRangeEndLineNumber === nextRange.startLineNumber) {\n          nextRange.startColumn += diffInCol;\n        }\n        if (oldRangeEndLineNumber === nextRange.endLineNumber) {\n          nextRange.endColumn += diffInCol;\n        }\n        nextRange.startLineNumber += diffInRow;\n        nextRange.endLineNumber += diffInRow;\n        nextRestriction.range = nextRange;\n      }\n      for (let i = changeIndex + 1; i < changesLength; i++) {\n        const nextChange = changes[i];\n        const rangeInChange = nextChange.range;\n        const rangeAsString = rangeInChange.toString();\n        const rangeMapValue = rangeMap[rangeAsString];\n        delete rangeMap[rangeAsString];\n        if (oldRangeEndLineNumber === rangeInChange.startLineNumber) {\n          rangeInChange.startColumn += diffInCol;\n        }\n        if (oldRangeEndLineNumber === rangeInChange.endLineNumber) {\n          rangeInChange.endColumn += diffInCol;\n        }\n        rangeInChange.startLineNumber += diffInRow;\n        rangeInChange.endLineNumber += diffInRow;\n        nextChange.range = rangeInChange;\n        rangeMap[rangeInChange.toString()] = rangeMapValue;\n      }\n    } else {\n      // Only Column might have changed\n      for (let i = restriction.index + 1; i < length; i++) {\n        const nextRestriction = restrictions[i];\n        const nextRange = nextRestriction.range;\n        if (nextRange.startLineNumber > oldRangeEndLineNumber) {\n          break;\n        } else {\n          nextRange.startColumn += diffInCol;\n          nextRange.endColumn += diffInCol;\n          nextRestriction.range = nextRange;\n        }\n      }\n      for (let i = changeIndex + 1; i < changesLength; i++) {\n        // rangeMap\n        const nextChange = changes[i];\n        const rangeInChange = nextChange.range;\n        const rangeAsString = rangeInChange.toString();\n        const rangeMapValue = rangeMap[rangeAsString];\n        delete rangeMap[rangeAsString];\n        if (rangeInChange.startLineNumber > oldRangeEndLineNumber) {\n          rangeMap[rangeInChange.toString()] = rangeMapValue;\n          break;\n        } else {\n          rangeInChange.startColumn += diffInCol;\n          rangeInChange.endColumn += diffInCol;\n          nextChange.range = rangeInChange;\n          rangeMap[rangeInChange.toString()] = rangeMapValue;\n        }\n      }\n    }\n    // }\n  };\n  const getInfoFrom = function (change, editableRange) {\n    const info = {};\n    const range = change.range;\n    // Get State\n    if (change.text === \"\") {\n      info.isDeletion = true;\n    } else if (\n      range.startLineNumber === range.endLineNumber &&\n      range.startColumn === range.endColumn\n    ) {\n      info.isAddition = true;\n    } else {\n      info.isReplacement = true;\n    }\n    // Get Position Of Range\n    info.startLineOfRange =\n      range.startLineNumber === editableRange.startLineNumber;\n    info.startColumnOfRange = range.startColumn === editableRange.startColumn;\n\n    info.endLineOfRange = range.endLineNumber === editableRange.endLineNumber;\n    info.endColumnOfRange = range.endColumn === editableRange.endColumn;\n\n    info.middleLineOfRange = !info.startLineOfRange && !info.endLineOfRange;\n\n    // Editable Range Span\n    if (editableRange.startLineNumber === editableRange.endLineNumber) {\n      info.rangeIsSingleLine = true;\n    } else {\n      info.rangeIsMultiLine = true;\n    }\n    return info;\n  };\n  const updateRestrictions = function (ranges) {\n    restrictions = deepClone(ranges).sort(sortRangesInAscendingOrder);\n    prepareRestrictions(restrictions);\n  };\n  const toggleHighlightOfEditableAreas = function (cssClasses) {\n    if (!model._hasHighlight) {\n      const cssClassForSingleLine =\n        cssClasses.cssClassForSingleLine || enums.SINGLE_LINE_HIGHLIGHT_CLASS;\n      const cssClassForMultiLine =\n        cssClasses.cssClassForMultiLine || enums.MULTI_LINE_HIGHLIGHT_CLASS;\n      const cssClassForRestrictedArea =\n        cssClasses.cssClassForRestrictedArea ||\n        enums.RESTRICTED_AREA_HIGHLIGHT_CLASS;\n\n      const decorations = restrictions.map(function (restriction) {\n        const decoration = {\n          range: restriction.range,\n          options: {\n            className: restriction.allowMultiline\n              ? cssClassForMultiLine\n              : cssClassForSingleLine,\n          },\n        };\n        if (restriction.label) {\n          decoration.hoverMessage = restriction.label;\n        }\n        return decoration;\n      });\n      decorations.push({\n        range: getEditorBoundaryExcludingBoundaryList(\n          model.getFullModelRange(),\n          restrictions.map((restriction) => restriction.range)\n        ),\n        options: {\n          className: cssClassForRestrictedArea,\n        },\n      });\n      model._oldDecorations = model.deltaDecorations([], decorations);\n      model._oldDecorationsSource = decorations.map(function (\n        decoration,\n        index\n      ) {\n        return Object.assign({}, decoration, {\n          id: model._oldDecorations[index],\n        });\n      });\n      model._hasHighlight = true;\n    } else {\n      model.deltaDecorations(model._oldDecorations, []);\n      delete model._oldDecorations;\n      delete model._oldDecorationsSource;\n      model._hasHighlight = false;\n    }\n  };\n  const handleUnhandledPromiseRejection = function () {\n    console.debug(\"handler for unhandled promise rejection\");\n  };\n  const setAllRangesToPrev = function (rangeMap) {\n    for (let key in rangeMap) {\n      const restriction = rangeMap[key];\n      restriction.range = restriction.prevRange;\n    }\n  };\n  const doesChangeHasMultilineConflict = function (restriction, text) {\n    return !restriction.allowMultiline && text.includes(\"\\n\");\n  };\n  const isChangeInvalidAsPerUser = function (restriction, value, range) {\n    return (\n      restriction.validate &&\n      !restriction.validate(value, range, restriction.lastInfo)\n    );\n  };\n\n  const manipulatorApi = {\n    _isRestrictedModel: true,\n    _isRestrictedValueValid: true,\n    _editableRangeChangeListener: [],\n    _isCursorAtCheckPoint: isCursorAtCheckPoint,\n    _currentCursorPositions: [],\n  };\n\n  prepareRestrictions(restrictions);\n  model._hasHighlight = false;\n  manipulatorApi._restrictionChangeListener = model.onDidChangeContent(\n    function (contentChangedEvent) {\n      const isUndoing = contentChangedEvent.isUndoing;\n      model._isRestrictedValueValid = true;\n      if (!(isUndoing && model.editInRestrictedArea)) {\n        const changes = contentChangedEvent.changes.sort(\n          sortRangesInAscendingOrder\n        );\n        const rangeMap = {};\n        const length = restrictions.length;\n        const isAllChangesValid = changes.every(function (change) {\n          const editedRange = change.range;\n          const rangeAsString = editedRange.toString();\n          rangeMap[rangeAsString] = null;\n          for (let i = 0; i < length; i++) {\n            const restriction = restrictions[i];\n            const range = restriction.range;\n            if (range.containsRange(editedRange)) {\n              if (doesChangeHasMultilineConflict(restriction, change.text)) {\n                return false;\n              }\n              rangeMap[rangeAsString] = restriction;\n              return true;\n            }\n          }\n          return false;\n        });\n        if (isAllChangesValid) {\n          changes.forEach(function (change, changeIndex) {\n            const changedRange = change.range;\n            const restriction = rangeMap[changedRange.toString()];\n            const editableRange = restriction.range;\n            const text = change.text || \"\";\n            /**\n             * Things to check before implementing the change\n             * - A | D | R => Addition | Deletion | Replacement\n             * - MC | SC => MultiLineChange | SingleLineChange\n             * - SOR | MOR | EOR => Change Occured in - Start Of Range | Middle Of Range | End Of Range\n             * - SSL | SML => Editable Range - Spans Single Line | Spans Multiple Line\n             */\n            const noOfLinesAdded = (text.match(/\\n/g) || []).length;\n            const noOfColsAddedAtLastLine = text.split(/\\n/g).pop().length;\n\n            const lineDiffInRange =\n              changedRange.endLineNumber - changedRange.startLineNumber;\n            const colDiffInRange =\n              changedRange.endColumn - changedRange.startColumn;\n\n            let finalLine = editableRange.endLineNumber;\n            let finalColumn = editableRange.endColumn;\n\n            let columnsCarriedToEnd = 0;\n            if (\n              editableRange.endLineNumber === changedRange.startLineNumber ||\n              editableRange.endLineNumber === changedRange.endLineNumber\n            ) {\n              columnsCarriedToEnd +=\n                editableRange.endColumn - changedRange.startColumn + 1;\n            }\n\n            const info = getInfoFrom(change, editableRange);\n            restriction.lastInfo = info;\n            if (info.isAddition || info.isReplacement) {\n              if (info.rangeIsSingleLine) {\n                /**\n                 * Only Column Change has occurred , so regardless of the position of the change\n                 * Addition of noOfCols is enough\n                 */\n                if (noOfLinesAdded === 0) {\n                  finalColumn += noOfColsAddedAtLastLine;\n                } else {\n                  finalLine += noOfLinesAdded;\n                  if (info.startColumnOfRange) {\n                    finalColumn += noOfColsAddedAtLastLine;\n                  } else if (info.endColumnOfRange) {\n                    finalColumn = noOfColsAddedAtLastLine + 1;\n                  } else {\n                    finalColumn = noOfColsAddedAtLastLine + columnsCarriedToEnd;\n                  }\n                }\n              }\n              if (info.rangeIsMultiLine) {\n                // Handling for Start Of Range is not required\n                finalLine += noOfLinesAdded;\n                if (info.endLineOfRange) {\n                  if (noOfLinesAdded === 0) {\n                    finalColumn += noOfColsAddedAtLastLine;\n                  } else {\n                    finalColumn = columnsCarriedToEnd + noOfColsAddedAtLastLine;\n                  }\n                }\n              }\n            }\n            if (info.isDeletion || info.isReplacement) {\n              if (info.rangeIsSingleLine) {\n                finalColumn -= colDiffInRange;\n              }\n              if (info.rangeIsMultiLine) {\n                if (info.endLineOfRange) {\n                  finalLine -= lineDiffInRange;\n                  finalColumn -= colDiffInRange;\n                } else {\n                  finalLine -= lineDiffInRange;\n                }\n              }\n            }\n            updateRange(\n              restriction,\n              editableRange,\n              finalLine,\n              finalColumn,\n              changes,\n              changeIndex\n            );\n          });\n          const values = model.getValueInEditableRanges();\n          const currentlyEditedRanges = {};\n          for (let key in rangeMap) {\n            const restriction = rangeMap[key];\n            const range = restriction.range;\n            const rangeString = restriction.label || range.toString();\n            const value = values[rangeString];\n            if (isChangeInvalidAsPerUser(restriction, value, range)) {\n              setAllRangesToPrev(rangeMap);\n              doUndo();\n              return; // Breaks the loop and prevents the triggerChangeListener\n            }\n            currentlyEditedRanges[rangeString] = value;\n          }\n          if (model._hasHighlight) {\n            model._oldDecorationsSource.forEach(function (object) {\n              object.range = model.getDecorationRange(object.id);\n            });\n          }\n          triggerChangeListenersWith(currentlyEditedRanges, values);\n        } else {\n          doUndo();\n        }\n      } else if (model.editInRestrictedArea) {\n        model._isRestrictedValueValid = false;\n      }\n    }\n  );\n  window.onerror = handleUnhandledPromiseRejection;\n  const exposedApi = {\n    editInRestrictedArea: false,\n    getCurrentEditableRanges: getCurrentEditableRanges,\n    getValueInEditableRanges: getValueInEditableRanges,\n    disposeRestrictions: disposeRestrictions,\n    onDidChangeContentInEditableRange: addEditableRangeListener,\n    updateRestrictions: updateRestrictions,\n    updateValueInEditableRanges: updateValueInEditableRanges,\n    toggleHighlightOfEditableAreas: toggleHighlightOfEditableAreas,\n  };\n  for (let funcName in manipulatorApi) {\n    Object.defineProperty(model, funcName, {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: manipulatorApi[funcName],\n    });\n  }\n  for (let apiName in exposedApi) {\n    Object.defineProperty(model, apiName, {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: exposedApi[apiName],\n    });\n  }\n  return model;\n};\nexport default constrainedModel;\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","monaco","dummyDiv","document","createElement","dummyEditorInstance","editor","create","editorInstanceConstructorName","constructor","name","editorModelConstructorName","getModel","isInstanceValid","valueToValidate","isModelValid","isRangesValid","ranges","Array","isArray","every","rangeObj","range","length","num","parseInt","allowMultiline","label","validate","TypeMustBe","type","additional","join","getEditorBoundaryExcludingBoundaryList","editorBoundary","boundaryList","finalBoundaryList","lastBoundaryDetails","forEach","boundary","index","startLineNumber","startColumn","push","endLineNumber","endColumn","byPassPrimitives","value","callback","this","freeze","Date","cloneArray","array","keys","arrayClone","i","cloner","object","clone","withProto","config","constructOptionForCode","reduce","acc","option","bind","codes","defineProperties","methods","andFreeze","withProtoAndFreeze","API","methodName","writable","configurable","undefined","Error","listenerFn","editorInstance","model","_isCursorAtCheckPoint","selections","getSelections","positions","map","selection","lineNumber","positionLineNumber","column","positionColumn","_currentCursorPositions","_uriRestrictionMap","manipulator","_listener","_editorInstance","_injectedResources","exposedMethods","initializeIn","domNode","getDomNode","_isInDevMode","addEventListener","_onChangeModelDisposable","onDidChangeModel","removeEventListener","newDomNode","addRestrictionsTo","modelToConstrain","rangeConstructor","Range","sortRangesInAscendingOrder","rangeObject1","rangeObject2","rangeA","rangeB","restrictions","sort","prepareRestrictions","content","getValue","restriction","lines","split","noOfLines","normalizedRange","actualStartCol","startLineNo","maxCols","Math","abs","actualEndLine","console","warn","actualEndCol","endLineNo","normalizeRange","startLine","startCol","endLine","endCol","_originalRange","slice","spansMultipleLines","getCurrentEditableRanges","assign","originalRange","doUndo","Promise","resolve","then","editInRestrictedArea","undo","_hasHighlight","_oldDecorationsSource","deltaDecorations","_oldDecorations","getDecorationRange","id","updateRange","finalLine","finalColumn","changes","changeIndex","oldRangeEndLineNumber","oldRangeEndColumn","prevRange","setEndPosition","changesLength","diffInCol","diffInRow","cursorPositions","noOfCursorPositions","filter","change","cursorPosition","nextRestriction","nextRange","nextChange","rangeInChange","rangeAsString","toString","rangeMapValue","rangeMap","handleUnhandledPromiseRejection","debug","setAllRangesToPrev","doesChangeHasMultilineConflict","text","includes","isChangeInvalidAsPerUser","lastInfo","manipulatorApi","_isRestrictedModel","_isRestrictedValueValid","_editableRangeChangeListener","some","position","posLineNumber","posCol","pushStackElement","_restrictionChangeListener","onDidChangeContent","contentChangedEvent","isUndoing","editedRange","containsRange","changedRange","editableRange","noOfLinesAdded","match","noOfColsAddedAtLastLine","pop","lineDiffInRange","colDiffInRange","columnsCarriedToEnd","info","isDeletion","isAddition","isReplacement","startLineOfRange","startColumnOfRange","endLineOfRange","endColumnOfRange","middleLineOfRange","rangeIsSingleLine","rangeIsMultiLine","getInfoFrom","values","getValueInEditableRanges","currentlyEditedRanges","rangeString","currentChanges","allChanges","currentRanges","triggerChangeListenersWith","window","onerror","exposedApi","getValueInRange","disposeRestrictions","dispose","updateValueInEditableRanges","updateRestrictions","toggleHighlightOfEditableAreas","onDidChangeContentInEditableRange","forceMoveMarkers","restrictionsMap","newRange","applyEdits","error","cssClasses","cssClassForSingleLine","cssClassForMultiLine","cssClassForRestrictedArea","decorations","decoration","options","className","hoverMessage","getFullModelRange","funcName","apiName","uri","removeRestrictionsIn","restrictedModel","disposeConstrainer","_devModeAction","toggleDevMode","addAction","contextMenuGroupId","contextMenuOrder","run","JSON","stringify","log"],"sourceRoot":""}